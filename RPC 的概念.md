# RPC 的概念

**参考文档**

[RPC是什么，看完你就知道了 - 掘金](https://juejin.cn/post/6861560477995139080)

[如何通俗的理解 RPC](https://zhuanlan.zhihu.com/p/36427583)

[通俗解释什么是 RPC 框架](https://www.zhihu.com/question/25536695)

---

## 什么是 RPC

RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 *HTTP请求* 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。RPC 它假定某些协议的存在，例如 TPC/UDP 等，为通信程序之间携带信息数据。在 OSI 网络七层模型中，RPC 跨越了传输层和应用层，RPC使得开发，包括网络分布式多程序在内的应用程序更加容易。最终解决的问题：**让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。**

&emsp;

## 为什么需要 RPC

随着企业 IT 服务的不断发展，单台服务器逐渐无法承受用户日益增长的请求压力时，就需要多台服务器联合起来构成「服务集群」共同对外提供服务。同时业务服务会随着产品需求的增多越来越肿，架构上必须进行服务拆分，一个完整的大型服务会被打散成很多很多独立的小服务，每个小服务会由独立的进程去管理来对外提供服务，这就是微服务。关于微服务的介绍可以看它的专题。

当用户的请求到来时，我们需要将用户的请求分散到多个服务去各自处理，然后又需要将这些子服务的结果汇总起来呈现给用户。那么服务之间该使用何种方式进行交互就是需要解决的核心问题。RPC 就是为解决服务之间信息交互而发明和存在的。

总结一下，核心主要是四个点：

* 服务化/微服务

* 分布式系统架构

* 服务可重用

* 系统间交互调用
  
  &emsp;

## 本地调用对比远程调用

### 本地调用详解

首先看一下下面这个例子，假设我们要调用函数Multiply来计算lvalue * rvalue的结果:

```java
int Multiply(int l, int r) {
   int y = l * r;
   return y;
}

int lvalue = 10;
int rvalue = 20;
int l_times_r = Multiply(lvalue, rvalue);
```

在最后一行的调用过程中，我们实际上执行了以下操作：

1. 将 lvalue 和 rvalue 的值压栈

2. 进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r

3. 执行第2行代码，计算 l * r ，并将结果存在 y

4. 将 y 的值压栈，然后从 Multiply 返回

5. 第8行，从栈中取出返回值 200 ，并赋值给 l_times_r

总体来说，在本地调用中，函数体是直接通过函数指针来指定的，我们调用 Multiply，编译器就自动帮我们调用它相应的函数指针。

&emsp;

### 远程调用的不同

在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply 是在另一个进程中执行的。这就带来了几个新问题：

1. **Call ID映射**。我们怎么告诉远程机器我们要调用 `Multiply` ，而不是 `Add` 或者 `FooBar` 呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。**所以，在 RPC 中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的**。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

2. **序列化和反序列化**。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用 C++，客户端用 Java 或者 Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。

3. **网络传输**。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了HTTP2。
   
   &emsp;

### 远程调用的简单实现

```cpp
// Client端 
// int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)
1. 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法
2. 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包
3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层
4. 等待服务器返回结果
5. 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r

// Server端
1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用std::map<std::string, std::function<>>
2. 等待请求
3. 得到一个请求后，将其数据包反序列化，得到Call ID
4. 通过在 call_id_map 中查找，得到相应的函数指针
5. 将lvalue和rvalue反序列化后，在本地调用 Multiply 函数，得到结果
6. 将结果序列化后通过网络返回给 Client
```

&emsp;

## RPC 框架的实现

![](https://pic1.zhimg.com/80/v2-6cd209d81cbdf968cbc83ab4baed8755_1440w.jpg?source=1940ef5c)

- 服务消费方（client）调用以本地调用方式调用服务；
- client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
- client stub 找到服务地址，并将消息发送到服务端；
- server stub 收到消息后进行解码；
- server stub 根据解码结果调用本地的服务；
- 本地服务执行并将结果返回给 server stub；
- server stub 将返回结果打包成消息并发送至消费方；
- client stub 接收到消息，并进行解码；
- 服务消费方得到最终结果。
