# Docker 介绍

**参考文档**

[Docker 入门教程 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html)

[可能是把Docker的概念讲的最清楚的一篇文章](http://dockone.io/article/6051)

---

## 环境配置的难点

软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说："它在我的机器可以跑了"（It works on my machine），言下之意就是，其他机器很可能跑不了。

传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等 ( Java 为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件 + 所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。

&emsp;

## 容器与虚拟机

### 虚拟机

虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。

&emsp;
虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点：

1. 资源占用多
   
   虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。

2. 冗余步骤多
   
   虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。

3. 启动慢
   
   启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。

&emsp;

### 容器

由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，或者说，在正常进程的外面套了一个保护层，对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势：

1. 启动快
   
   容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。

2. 资源占用少
   
   容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。

3. 体积小
   
   容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。一句话概括，**容器就是将软件打包成标准化单元，以用于开发、交付和部署**。  

- 容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。
- 容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。
- 容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。

&emsp;

### Docker

**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口**。Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

Docker 的主要用途，目前有三大类：

* **提供一次性的环境**。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

* **提供弹性的云服务**。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

* **组建微服务架构**。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。

&emsp;

## Docker 概念

Docker 的三个基本要素是镜像 (image)，容器 (container) 和仓库 (repository)。

### 镜像

镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是 image 镜像文件。只有通过这个镜像文件才能生成 Docker 容器实例(类似 Java 中 new 出来一个对象)。



UnionFS (联合文件系统): Union 文件系统 (UnionFS) 是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下 (unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像 (没有父镜像)，可以制作各种具体的应用镜像。

&emsp;

### 工作流程

Docker 是一个 Client-Server 结构的系统，其守护进程运行在主机上，然后通过 socket 连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。`docker run` 首先会去本地查找是否有对应的镜像，如果有直接生成容器，如果没有则需要去远程仓库拉去相对应的镜像存放在本地。

&emsp;

## Docker 常用指令

`docker image` 列出主机上的镜像。

该指令执行完后会出现一个列表，具体含义如下：

| Repository | Tag      | Image ID | Created | Virtual Size |
| ---------- | -------- | -------- | ------- | ------------ |
| 镜像的仓库源     | 镜像的标签版本号 | 对应ID     | 创建时间    | 大小           |

同一个仓库源可以有不同的 Tag，代表不同的版本，使用 `Repository : Tag` 来区分镜像。

如果不指定具体的版本标签默认使用最新版本。

&emsp;

`docker search`  + 镜像名

查询某一个镜像是否存在。

&emsp;

`docker pull` + 镜像名

从远程仓库拉去镜像。

&emsp;

`docker rmi -f image_id`

通过指定镜像ID删除镜像。

&emsp;

`docker run [OPTIONS] image_name`

新建并启动一个容器

`--name` : 为容器指定一个名称

`-d` : 后台运行容器并返回容器 Id ，即启动守护式容器

`-it` : 以交互模式运行容器，并且为容器分配一个伪输入终端

`-p hostPort:containerPort` : 指定端口映射，`hostPort` 代表着希望访问的主机的端口号，找到 docker，`containerPort` 代表着访问 docker 内部哪一个容器。

&emsp;

`docker ps`

列出当前正在运行的容器，如果需要列出历史上运行过的加上参数 `-a`，如果只看 id 用参数 `-q`。

&emsp;

`docker start container_id` 启动已经停止的容器

`docker restart container_id` 重启容器

`docker stop container_id` 停止容器

`docker kill container_id` 强制停止容器

`docker rm container_id` 删除已经停止的容器

&emsp;

`docker logs container_id` 

查看容器的相应日志

&emsp;

`docker exec -it container_id bashShell`

进入正在运行的容器并以命令行交互，`exec` 是在容器中打开新的终端，并且可以启动新的进程，用 `exit` 退出，不会导致容器的停止。

&emsp;

`docker cp container_id:container_path local_path`

从容器内拷贝文件到主机上。

&emsp;

`docker export container_id > file.tar`

`export` 导出容器的内容留作为一个 tar 归档文件。

`cat file.tar | docker import - 镜像用户/镜像名:镜像版本号`

`import` 从 tar 包中的内容创建一个新的文件系统再导入为镜像。
